# Система разграничения прав доступа (RBAC)

Данный документ описывает структуру и логику управления ограничениями доступа, реализованными в проекте согласно ТЗ.

## 1. Концепция (Схема управления)
Система авторизации построена на подходе **RBAC** (Role-Based Access Control) с высокой степенью гранулярности на уровне ресурсов.

**Основные сущности в БД:**
- **Roles (Роли)**: Определяют тип профиля (категорию лиц). В нашей системе это `ADMIN`, `USER` (покупатель) и `BUSINESS` (продавец).
- **Resources (Ресурсы)**: Абстрактные области приложения (или таблицы), к которым можно получить доступ. Примеры: `USERS`, `GOODS`, `ORDERS`, `RULES`.
- **Rules (Правила — Таблица `access_roles_rules`)**: Устанавливают связь между конкретной *ролью* и конкретным *ресурсом*. Содержит набор булевых флагов (`read_p`, `read_all_p`, `create_p`, `update_p`, `update_all_p`, `delete_p`, `delete_all_p`), которые точно определяют, что именно роль может делать в этом ресурсе.

**Почему выбрана такая архитектура?**
Такая схема позволяет управлять доступом *без изменения кода (без хардкода)*. Если бизнесу вдруг понадобится дать право на просмотр заказов, администратору в БД (или через API `GET/PATCH /rules`) достаточно изменить флаг `read_all_p` на `True` для ресурса `ORDERS` и роли `BUSINESS`. Проверка в коде автоматически учтёт это изменение.

## 2. Изолированная модель токенов (Аутентификация)
В системе предусмотрено две группы посетителей:
- **Обычные пользователи и Администраторы (Таблица `users`)**
- **Бизнес-аккаунты (Таблица `businesses`)**

Для них реализованы отдельные куки-токены (`userAccessToken` и `businessAccessToken`). Это решает проблему изоляции бизнес-логики:
1. Юзер не может зайти на эндпоинт, где требуется физический профиль бизнеса (со своими специфичными полями, например, баланс или ИНН).
2. Зависимости (Dependencies) умеют отличать ситуацию "не залогинен" от "залогинен как другой тип".

## 3. Обработка ошибок авторизации в коде
Проверка прав доступа реализована в виде универсальных FastAPI-зависимостей: `CheckUserPermission` и `CheckBusinessPermission` (см. `app/rules/dependencies.py`).

**Логика их работы полностью покрывает требования ТЗ:**
1. Если по входящему запросу **не удается определить залогиненного пользователя** (нет никаких кук или заголовка `Authorization`) — выбрасывается ошибка:
   - Срабатывает `raise TokenAbsendException`, которая через слой обработки (см. `app/exceptions.py`) возвращает статус **401 Unauthorized**.
2. Если пользователь определен, но пытается зайти на эндпоинт для другого типа аккаунта (например, обычный юзер лезет в специфичный эндпоинт бизнеса) — возвращается статус **403 Forbidden** (`raise InsufficientPermissionsException`).
3. Если пользователь определен и находится на "своей территории", код обращается к БД: ищет правило (`Rules`) по связке ID роли пользователя в связке с ID запрашиваемого ресурса ресурса.
4. Выполняется проверка требуемого флага в правиле (используется `getattr` для динамической проверки `action`).
   - Если флага нет, ресурса нет, или флаг равен `False` — возвращается статус **403 Forbidden**.
   - Если флаг равен `True` - выполнение передаётся дальше, пользователь получает доступ к запрашиваемому ресурсу.

## 4. API для Администратора
Реализован отдельный роутер `app/rules/router.py`, доступ к которому имеет только роль `ADMIN` (контролируется флагами ресурса `RULES`).
- `GET /rules` - выводит массив всех правил, существующих в системе.
- `PATCH /rules/{rule_id}` - позволяет динамически обновлять флаги (`create_p`, `update_p` и др.) для конкретного правила, управляя политикой доступа на лету.

## 5. Тестовые данные (Seed)
В корне проекта лежит скрипт `seed.sql`. После поднятия БД и применения миграций Alembic необходимо выполнить этот скрипт. Скрипт наполняет таблицы всеми необходимыми тестовыми данными: ролями (`Roles`), ресурсами (`Resources`) и подробной матрицей правил (`access_roles_rules`), связывающей их. Это обеспечивает минимальную отработку приложения "из коробки" для демонстрации всей гибкости системы.

Также скрипт создает тестового администратора:
- **Логин (Email)**: `admin@admin.com`
- **Пароль**: `admin123`
- **Роль**: `ADMIN`
